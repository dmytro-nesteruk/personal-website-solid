import{createSignal as k,getOwner as W,getListener as M,onCleanup as F,startTransition as x,sharedConfig as R}from"solid-js";import{isServer as p,getRequestEvent as m}from"solid-js/web";import{j as N,l as D}from"./routing-CmSqAZBG.js";import{provideRequestEvent as B}from"solid-js/web/storage";import{H3Event as C,setResponseStatus as G,sendRedirect as K,setHeader as z,getRequestIP as J,getResponseStatus as Q,getResponseStatusText as V,getCookie as X,setCookie as Y,getRequestURL as Z,getResponseHeaders as ee,getResponseHeader as te,setResponseHeader as ne,appendResponseHeader as re,removeResponseHeader as oe,getRequestWebStream as se}from"h3";import{AsyncLocalStorage as ae}from"node:async_hooks";const ie="Location",ce=5e3,ue=18e4;let H=new Map;p||setInterval(()=>{const t=Date.now();for(let[e,n]of H.entries())!n[3].count&&t-n[0]>ue&&H.delete(e)},3e5);function T(){if(!p)return H;const t=m();if(!t)throw new Error("Cannot find cache context");return(t.router||(t.router={})).cache||(t.router.cache=new Map)}function I(t,e){t.GET&&(t=t.GET);const n=(...s)=>{const a=T(),c=D(),f=W()?N():void 0,y=Date.now(),l=e+_(s);let o=a.get(l),v;if(p){const i=m();if(i){const d=(i.router||(i.router={})).dataOnly;if(d){const g=i&&(i.router.data||(i.router.data={}));if(g&&l in g)return g[l];if(Array.isArray(d)&&!d.includes(l))return g[l]=void 0,Promise.resolve()}}}if(M()&&!p&&(v=!0,F(()=>o[3].count--)),o&&o[0]&&(p||c==="native"||o[3].count||Date.now()-o[0]<ce)){v&&(o[3].count++,o[3][0]()),o[2]==="preload"&&c!=="preload"&&(o[0]=y);let i=o[1];return c!=="preload"&&(i="then"in o[1]?o[1].then(w(!1),w(!0)):w(!1)(o[1]),!p&&c==="navigate"&&x(()=>o[3][1](o[0]))),i}let h=!p&&R.context&&R.has(l)?R.load(l):t(...s);if(o?(o[0]=y,o[1]=h,o[2]=c,!p&&c==="navigate"&&x(()=>o[3][1](o[0]))):(a.set(l,o=[y,h,c,k(y)]),o[3].count=0),v&&(o[3].count++,o[3][0]()),p){const i=m();if(i&&i.router.dataOnly)return i.router.data[l]=h}if(c!=="preload"&&(h="then"in h?h.then(w(!1),w(!0)):w(!1)(h)),p&&R.context&&R.context.async&&!R.context.noHydrate){const i=m();(!i||!i.serverOnly)&&R.context.serialize(l,h)}return h;function w(i){return async d=>{if(d instanceof Response){if(d.headers.has("Location")){f&&x(()=>{let g=d.headers.get(ie);g&&g.startsWith("/")?f(g,{replace:!0}):!p&&g&&(window.location.href=g)});return}d.customBody&&(d=await d.customBody())}if(i)throw d;return d}}};return n.keyFor=(...s)=>e+_(s),n.key=e,n}I.set=(t,e)=>{const n=T(),s=Date.now();let a=n.get(t);a?(a[0]=s,a[1]=e,a[2]="preload"):(n.set(t,a=[s,e,,k(s)]),a[3].count=0)};I.clear=()=>T().clear();function _(t){return JSON.stringify(t,(e,n)=>fe(n)?Object.keys(n).sort().reduce((s,a)=>(s[a]=n[a],s),{}):n)}function fe(t){let e;return t!=null&&typeof t=="object"&&(!(e=Object.getPrototypeOf(t))||e===Object.prototype)}function le(t={}){let e,n=!1;const s=r=>{if(e&&e!==r)throw new Error("Context conflict")};let a;if(t.asyncContext){const r=t.AsyncLocalStorage||globalThis.AsyncLocalStorage;r?a=new r:console.warn("[unctx] `AsyncLocalStorage` is not provided.")}const c=()=>{if(a&&e===void 0){const r=a.getStore();if(r!==void 0)return r}return e};return{use:()=>{const r=c();if(r===void 0)throw new Error("Context is not available");return r},tryUse:()=>c(),set:(r,f)=>{f||s(r),e=r,n=!0},unset:()=>{e=void 0,n=!1},call:(r,f)=>{s(r),e=r;try{return a?a.run(r,f):f()}finally{n||(e=void 0)}},async callAsync(r,f){e=r;const y=()=>{e=r},l=()=>e===r?y:void 0;O.add(l);try{const o=a?a.run(r,f):f();return n||(e=void 0),await o}finally{O.delete(l)}}}}function de(t={}){const e={};return{get(n,s={}){return e[n]||(e[n]=le({...t,...s})),e[n],e[n]}}}const S=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof global<"u"?global:typeof window<"u"?window:{},A="__unctx__",pe=S[A]||(S[A]=de()),ye=(t,e={})=>pe.get(t,e),q="__unctx_async_handlers__",O=S[q]||(S[q]=new Set);function ge(t){let e;const n=U(t),s={duplex:"half",method:t.method,headers:t.headers};return t.node.req.body instanceof ArrayBuffer?new Request(n,{...s,body:t.node.req.body}):new Request(n,{...s,get body(){return e||(e=xe(t),e)}})}function he(t){return t.web??={request:ge(t),url:U(t)},t.web.request}function Re(){return Te()}const j=Symbol("$HTTPEvent");function we(t){return typeof t=="object"&&(t instanceof C||t?.[j]instanceof C||t?.__is_event__===!0)}function u(t){return function(...e){let n=e[0];if(we(n))e[0]=n instanceof C||n.__is_event__?n:n[j];else{if(!globalThis.app.config.server.experimental?.asyncContext)throw new Error("AsyncLocalStorage was not enabled. Use the `server.experimental.asyncContext: true` option in your app configuration to enable it. Or, pass the instance of HTTPEvent that you have as the first argument to the function.");if(n=Re(),!n)throw new Error("No HTTPEvent found in AsyncLocalStorage. Make sure you are using the function within the server runtime.");e.unshift(n)}return t(...e)}}const U=u(Z),me=u(J),$=u(G),L=u(Q),be=u(V),b=u(ee),P=u(te),Se=u(ne),ve=u(re),Ue=u(K),We=u(X),Me=u(Y),Fe=u(z),xe=u(se),Ee=u(oe),Ce=u(he);function He(){return ye("nitro-app",{asyncContext:!!globalThis.app.config.server.experimental?.asyncContext,AsyncLocalStorage:ae})}function Te(){return He().use().event}const E=Symbol("fetchEvent");function _e(t){return{request:Ce(t),response:Oe(t),clientAddress:me(t),locals:{},nativeEvent:t}}function Ae(t){return{...t}}function Ne(t){if(!t[E]){const e=_e(t);t[E]=e}return t[E]}class qe{event;constructor(e){this.event=e}get(e){const n=P(this.event,e);return Array.isArray(n)?n.join(", "):n||null}has(e){return this.get(e)!==void 0}set(e,n){return Se(this.event,e,n)}delete(e){return Ee(this.event,e)}append(e,n){ve(this.event,e,n)}getSetCookie(){const e=P(this.event,"Set-Cookie");return Array.isArray(e)?e:[e]}forEach(e){return Object.entries(b(this.event)).forEach(([n,s])=>e(Array.isArray(s)?s.join(", "):s,n,this))}entries(){return Object.entries(b(this.event)).map(([e,n])=>[e,Array.isArray(n)?n.join(", "):n])[Symbol.iterator]()}keys(){return Object.keys(b(this.event))[Symbol.iterator]()}values(){return Object.values(b(this.event)).map(e=>Array.isArray(e)?e.join(", "):e)[Symbol.iterator]()}[Symbol.iterator](){return this.entries()[Symbol.iterator]()}}function Oe(t){return{get status(){return L(t)},set status(e){$(t,e)},get statusText(){return be(t)},set statusText(e){$(t,L(),e)},headers:new qe(t)}}function De(t,e,n){if(typeof t!="function")throw new Error("Export from a 'use server' module must be a function");const s="";return new Proxy(t,{get(a,c,r){if(c==="url")return`${s}/_server?id=${encodeURIComponent(e)}&name=${encodeURIComponent(n)}`;if(c==="GET")return r},apply(a,c,r){const f=m();if(!f)throw new Error("Cannot call server function outside of a request");const y=Ae(f);return y.locals.serverFunctionMeta={id:e+"#"+n},y.serverOnly=!0,B(y,()=>t.apply(c,r))}})}export{De as a,Ne as b,I as c,Ue as d,$ as e,Fe as f,We as g,Me as s};
